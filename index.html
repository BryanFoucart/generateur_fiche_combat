<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <title>Générateur de Combat</title>
    <style>
      body {
        font-family: Arial;
        padding: 20px;
      }

      label {
        display: block;
        margin-top: 10px;
      }

      .bloc {
        border: 1px solid #ccc;
        padding: 15px;
        margin-top: 20px;
      }

      .capacite-container {
        margin-left: 20px;
        margin-bottom: 10px;
      }

      .companion-container {
        border: 1px dashed #aaa;
        padding: 10px;
        margin-top: 10px;
      }

      textarea {
        width: 100%;
        height: 300px;
      }
    </style>
  </head>

  <body>
    <h2>Générateur de Fiche de Combat</h2>

    <div>
      <label
        >Nombre de personnages dans le Groupe 1 :
        <input
          type="number"
          id="nbGroupe1"
          value="1"
          min="1"
          onchange="genererFormulairesGroupes()"
        />
      </label>
      <label
        >Nombre de personnages dans le Groupe 2 :
        <input
          type="number"
          id="nbGroupe2"
          value="1"
          min="1"
          onchange="genererFormulairesGroupes()"
        />
      </label>
    </div>

    <div id="combat-form"></div>

    <button onclick="genererHTML()">Générer le Code HTML</button>

    <h2>Résultat HTML :</h2>
    <textarea id="resultat" readonly></textarea>

    <script>
      function genererFormulairesGroupes() {
        const nb1 = parseInt(document.getElementById("nbGroupe1").value);
        const nb2 = parseInt(document.getElementById("nbGroupe2").value);

        // 1. Sauvegarder les données déjà remplies
        const existingData = {};
        const inputs = document.querySelectorAll(
          "#combat-form input, #combat-form select, #combat-form textarea"
        );
        inputs.forEach((input) => {
          if (input.id) {
            existingData[input.id] =
              input.type === "checkbox" ? input.checked : input.value;
          }
        });

        // Sauvegarder les données des invocations
        const existingCompanions = {};
        const groups = ["g1_p", "g2_p"];
        const maxPersonnes = Math.max(nb1, nb2);

        groups.forEach((group) => {
          for (let i = 0; i < maxPersonnes; i++) {
            const prefix = `${group}${i}`;
            const compContainer = document.getElementById(
              `${prefix}_compagnons`
            );
            if (compContainer) {
              const companions = [];
              const currentCompanions = compContainer.getElementsByClassName(
                "companion-container"
              );
              Array.from(currentCompanions).forEach((comp, idx) => {
                companions.push({
                  nom: comp.querySelector(`.${prefix}_comp_nom`)?.value || "",
                  race: comp.querySelector(`.${prefix}_comp_race`)?.value || "",
                  vitalite:
                    comp.querySelector(`.${prefix}_comp_vitalite`)?.value || "",
                  vitesse:
                    comp.querySelector(`.${prefix}_comp_vitesse`)?.value || "",
                  degats:
                    comp.querySelector(`.${prefix}_comp_degats`)?.value || "",
                  capacites:
                    comp.querySelector(`#${prefix}_comp${idx}_capacites_input`)
                      ?.value || "",
                });
              });
              existingCompanions[prefix] = companions;
            }
          }
        });

        // 2. Regénérer les formulaires
        let html = "";

        html += `<h3>Groupe 1</h3>`;
        for (let i = 0; i < nb1; i++) {
          html += createCharacterForm(`g1_p${i}`, `Personnage ${i + 1}`);
        }

        html += `<h3>Groupe 2</h3>`;
        for (let i = 0; i < nb2; i++) {
          html += createCharacterForm(`g2_p${i}`, `Personnage ${i + 1}`);
        }

        document.getElementById("combat-form").innerHTML = html;

        // 3. Réinjecter les données
        for (const id in existingData) {
          const el = document.getElementById(id);
          if (el) {
            if (el.type === "checkbox") {
              el.checked = existingData[id];
              if (el.onchange) el.onchange();
            } else {
              el.value = existingData[id];
              if (el.oninput) el.oninput();
            }
          }
        }

        // 4. Restaurer les invocations
        for (const prefix in existingCompanions) {
          const nbCompagnonsEl = document.getElementById(
            `${prefix}_nbCompagnons`
          );
          if (nbCompagnonsEl) {
            nbCompagnonsEl.value = existingCompanions[prefix].length;
            updateCompanions(prefix);

            // Restaurer les données des invocations
            const container = document.getElementById(`${prefix}_compagnons`);
            if (container) {
              existingCompanions[prefix].forEach((comp, idx) => {
                const newContainer = container.children[idx];
                if (newContainer) {
                  newContainer.querySelector(`.${prefix}_comp_nom`).value =
                    comp.nom;
                  newContainer.querySelector(`.${prefix}_comp_race`).value =
                    comp.race;
                  newContainer.querySelector(`.${prefix}_comp_vitalite`).value =
                    comp.vitalite;
                  newContainer.querySelector(`.${prefix}_comp_vitesse`).value =
                    comp.vitesse;
                  newContainer.querySelector(`.${prefix}_comp_degats`).value =
                    comp.degats;

                  const capacitesInput = newContainer.querySelector(
                    `#${prefix}_comp${idx}_capacites_input`
                  );
                  if (capacitesInput) {
                    capacitesInput.value = comp.capacites;
                    parseCapacitesInvocations(prefix, idx);
                  }
                }
              });
            }
          }
        }
      }

      function createCharacterForm(idPrefix, label) {
        return `
<div class="bloc">
<h3>${label}</h3>
<label>Nom :
<input type="text" id="${idPrefix}_nom">
</label>
<label>Race :
<select id="${idPrefix}_classe">
<option value="abyssal">Abyssal</option>
<option value="djöllfulin">Djöllfulin</option>
<option value="elfe">Elfe</option>
<option value="entomothrope">Entomothrope</option>
<option value="géant">Géant</option>
<option value="humain">Humain</option>
<option value="hybride">Hybride</option>
<option value="naga">Naga</option>
<option value="nain">Nain</option>
<option value="orc">Orc</option>
<option value="stryge-blanc">Stryge Blanc</option>
<option value="stryge-noir">Stryge Noir</option>
<option value="thérianthrope">Thérianthrope</option>
<option value="vampire">Vampire</option>
</select>
</label>

<label>Vitalité :
<input type="number" id="${idPrefix}_vitalite">
</label>
<label>Vitesse :
<input type="number" id="${idPrefix}_vitesse">
</label>
<label>
<input type="checkbox" id="${idPrefix}_corrompu" onchange="toggleAbsorption('${idPrefix}')"> Corrompu ?
</label>
<div id="${idPrefix}_absorptionBloc" style="display: none;">
<label>Absorption (%) :
<input type="number" id="${idPrefix}_absorption" value="0">
</label>
</div>
<label>Dégâts :
<input type="number" id="${idPrefix}_degats">
</label>

<label>Capacités spéciales (format : "Titre : Description", une par ligne) :
<button type="button" onclick="ajouterSpoiler('${idPrefix}_capacites_input')">Ajouter Spoiler</button>
<textarea id="${idPrefix}_capacites_input" oninput="parseCapacites('${idPrefix}')" placeholder="EXEMPLE
Rapidité : permet d'attaquer à deux reprises.
Hydro cyno : Régénère la vitalité lorsqu'elle atteint 25%.
Attache ensablée : À chaque attache réussie, la cible s'affaiblit et réduit les dégâts de sa prochaine attaque à hauteur de 10% des dégâts du corrompu. Non réalisable dans la région des 'Mers & Océans'."></textarea>
</label>
<div id="${idPrefix}_capacites"></div>

<label>Nombre d'invocations :
<input type="number" id="${idPrefix}_nbCompagnons" value="0" min="0" onchange="updateCompanions('${idPrefix}')">
</label>
<div id="${idPrefix}_compagnons"></div>

<div class="character-actions">
  <button onclick="exporterPersonnage('${idPrefix}')">Exporter ce personnage</button>
  <input type="file" id="${idPrefix}_import" accept=".json" onchange="importerPersonnage(event, '${idPrefix}')" style="display: none;">
  <button onclick="document.getElementById('${idPrefix}_import').click()">Importer un personnage</button>
</div>
</div>
`;
      }

      function escapeHtml(text) {
        return text
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function parseCapacites(prefix) {
        const input = document.getElementById(
          `${prefix}_capacites_input`
        ).value;
        const container = document.getElementById(`${prefix}_capacites`);
        container.innerHTML = ""; // Reset

        // Séparer d'abord par les spoilers
        const segments = input.split(/(\[spoiler\].*?\[\/spoiler\])/s);
        let currentLines = [];

        segments.forEach((segment) => {
          if (segment.trim() === "") return;

          if (segment.startsWith("[spoiler]")) {
            // Traiter le contenu du spoiler comme un seul élément
            const spoilerContent = segment
              .replace("[spoiler]", "")
              .replace("[/spoiler]", "")
              .trim();

            if (spoilerContent) {
              currentLines.push(spoilerContent);
            }
          } else {
            // Traiter les lignes normales et @not
            const lines = segment.split("\n").filter((l) => l.trim() !== "");
            let tempLines = [];

            for (let i = 0; i < lines.length; i++) {
              if (lines[i].trim() === "@not") {
                // Si on trouve @not, on fusionne la ligne précédente avec la suivante
                if (tempLines.length > 0 && i + 1 < lines.length) {
                  const lastLine = tempLines.pop();
                  tempLines.push(lastLine + "\n" + lines[i + 1]);
                  i++; // Sauter la ligne suivante
                }
              } else {
                tempLines.push(lines[i]);
              }
            }

            currentLines.push(...tempLines);
          }
        });

        currentLines.forEach((line, index) => {
          // Nettoyer les éventuels @not restants
          const cleanLine = line
            .split("\n")
            .filter((l) => l.trim() !== "@not")
            .join("\n");

          // Pour les lignes normales, ne prendre en compte que le premier ":"
          const firstColonIndex = cleanLine.indexOf(":");
          if (firstColonIndex !== -1) {
            const titre = cleanLine.substring(0, firstColonIndex).trim();
            const description = cleanLine.substring(firstColonIndex + 1).trim();

            // Échapper les caractères spéciaux pour l'HTML
            const escapedTitre = escapeHtml(titre);
            const escapedDescription = escapeHtml(description);

            container.innerHTML += `
<div class="capacite-container">
<input type="hidden" class="${prefix}_titreCapacite" value="${escapedTitre}">
<input type="hidden" class="${prefix}_descriptionCapacite" value="${escapedDescription}">
<p><strong><em>${escapedTitre}</em></strong> : ${escapedDescription.replace(
              /\n/g,
              "<br>"
            )}</p>
<label>État :
<select class="${prefix}_classeCapacite">
<option value="capacité_spéciale">Neutre</option>
<option value="capacité_spéciale active">Active</option>
<option value="capacité_spéciale passive">Passive</option>
<option value="capacité_spéciale bloquée">Bloquée</option>
<option value="capacité_spéciale utilisée">Utilisée</option>
<option value="capacité_spéciale annulée">Annulée</option>
<option value="capacité_spéciale inactive">Inactive</option>
</select>
</label>
</div>
`;
          } else {
            // Si pas de ":", traiter comme une capacité sans titre
            const escapedLine = escapeHtml(cleanLine);
            container.innerHTML += `
<div class="capacite-container">
<input type="hidden" class="${prefix}_titreCapacite" value="Capacité ${
              index + 1
            }">
<input type="hidden" class="${prefix}_descriptionCapacite" value="${escapedLine}">
<p><strong><em>Capacité ${index + 1}</em></strong> : ${escapedLine.replace(
              /\n/g,
              "<br>"
            )}</p>
<label>État :
<select class="${prefix}_classeCapacite">
<option value="capacité_spéciale">Neutre</option>
<option value="capacité_spéciale active">Active</option>
<option value="capacité_spéciale passive">Passive</option>
<option value="capacité_spéciale bloquée">Bloquée</option>
<option value="capacité_spéciale utilisée">Utilisée</option>
<option value="capacité_spéciale annulée">Annulée</option>
<option value="capacité_spéciale inactive">Inactive</option>
</select>
</label>
</div>
`;
          }
        });
      }

      function updateCompanions(prefix) {
        const nb = parseInt(
          document.getElementById(`${prefix}_nbCompagnons`).value
        );
        const container = document.getElementById(`${prefix}_compagnons`);

        // Sauvegarder les données existantes des invocations
        const existingCompanions = [];
        const currentCompanions = container.getElementsByClassName(
          "companion-container"
        );
        Array.from(currentCompanions).forEach((comp, idx) => {
          const companion = {
            nom: comp.querySelector(`.${prefix}_comp_nom`)?.value || "",
            race: comp.querySelector(`.${prefix}_comp_race`)?.value || "",
            vitalite:
              comp.querySelector(`.${prefix}_comp_vitalite`)?.value || "",
            vitesse: comp.querySelector(`.${prefix}_comp_vitesse`)?.value || "",
            degats: comp.querySelector(`.${prefix}_comp_degats`)?.value || "",
            capacites:
              comp.querySelector(`#${prefix}_comp${idx}_capacites_input`)
                ?.value || "",
          };
          existingCompanions.push(companion);
        });

        // Générer le nouveau HTML
        container.innerHTML = "";
        for (let i = 0; i < nb; i++) {
          container.innerHTML += `
<div class="companion-container">
<h4>Invocation ${i + 1}</h4>
<label>Nom :
<input type="text" class="${prefix}_comp_nom">
</label>
<label>Race :
<select class="${prefix}_comp_race">
<option value="invocation">Invocation</option>
</select>
</label>
<label>Vitalité :
<input type="number" class="${prefix}_comp_vitalite">
</label>
<label>Vitesse :
<input type="number" class="${prefix}_comp_vitesse">
</label>
<label>Dégâts :
<input type="number" class="${prefix}_comp_degats">
</label>
<label>Capacités spéciales (format : "Titre : Description", une par ligne) :
<button type="button" onclick="ajouterSpoiler('${prefix}_comp${i}_capacites_input')">Ajouter Spoiler</button>
<textarea id="${prefix}_comp${i}_capacites_input" oninput="parseCapacitesInvocations('${prefix}', ${i})" placeholder="EXEMPLE
Rapidité : permet d'attaquer à deux reprises.
Hydro cyno : Régénère la vitalité lorsqu'elle atteint 25%.
Attache ensablée : À chaque attache réussie, la cible s'affaiblit et réduit les dégâts de sa prochaine attaque à hauteur de 10% des dégâts du corrompu. Non réalisable dans la région des 'Mers & Océans'."></textarea>
</label>
<div id="${prefix}_comp${i}_capacites"></div>
</div>
`;
        }

        // Restaurer les données sauvegardées
        existingCompanions.forEach((comp, idx) => {
          if (idx < nb) {
            // Ne restaurer que si l'invocation existe toujours
            const newContainer = container.children[idx];
            if (newContainer) {
              newContainer.querySelector(`.${prefix}_comp_nom`).value =
                comp.nom;
              newContainer.querySelector(`.${prefix}_comp_race`).value =
                comp.race;
              newContainer.querySelector(`.${prefix}_comp_vitalite`).value =
                comp.vitalite;
              newContainer.querySelector(`.${prefix}_comp_vitesse`).value =
                comp.vitesse;
              newContainer.querySelector(`.${prefix}_comp_degats`).value =
                comp.degats;

              const capacitesInput = newContainer.querySelector(
                `#${prefix}_comp${idx}_capacites_input`
              );
              if (capacitesInput) {
                capacitesInput.value = comp.capacites;
                parseCapacitesInvocations(prefix, idx);
              }
            }
          }
        });
      }

      function parseCapacitesInvocations(prefix, idx) {
        const input = document.getElementById(
          `${prefix}_comp${idx}_capacites_input`
        ).value;
        const container = document.getElementById(
          `${prefix}_comp${idx}_capacites`
        );
        container.innerHTML = ""; // Reset

        // Séparer d'abord par les spoilers
        const segments = input.split(/(\[spoiler\].*?\[\/spoiler\])/s);
        let currentLines = [];

        segments.forEach((segment) => {
          if (segment.trim() === "") return;

          if (segment.startsWith("[spoiler]")) {
            // Traiter le contenu du spoiler comme un seul élément
            const spoilerContent = segment
              .replace("[spoiler]", "")
              .replace("[/spoiler]", "")
              .trim();

            if (spoilerContent) {
              currentLines.push(spoilerContent);
            }
          } else {
            // Traiter les lignes normales et @not
            const lines = segment.split("\n").filter((l) => l.trim() !== "");
            let tempLines = [];

            for (let i = 0; i < lines.length; i++) {
              if (lines[i].trim() === "@not") {
                // Si on trouve @not, on fusionne la ligne précédente avec la suivante
                if (tempLines.length > 0 && i + 1 < lines.length) {
                  const lastLine = tempLines.pop();
                  tempLines.push(lastLine + "\n" + lines[i + 1]);
                  i++; // Sauter la ligne suivante
                }
              } else {
                tempLines.push(lines[i]);
              }
            }

            currentLines.push(...tempLines);
          }
        });

        currentLines.forEach((line, index) => {
          // Nettoyer les éventuels @not restants
          const cleanLine = line
            .split("\n")
            .filter((l) => l.trim() !== "@not")
            .join("\n");

          // Pour les lignes normales, ne prendre en compte que le premier ":"
          const firstColonIndex = cleanLine.indexOf(":");
          if (firstColonIndex !== -1) {
            const titre = cleanLine.substring(0, firstColonIndex).trim();
            const description = cleanLine.substring(firstColonIndex + 1).trim();

            // Échapper les caractères spéciaux pour l'HTML
            const escapedTitre = escapeHtml(titre);
            const escapedDescription = escapeHtml(description);

            container.innerHTML += `
<div class="capacite-container">
<input type="hidden" class="${prefix}_comp${idx}_titreCapacite" value="${escapedTitre}">
<input type="hidden" class="${prefix}_comp${idx}_descriptionCapacite" value="${escapedDescription}">
<p><strong><em>${escapedTitre}</em></strong> : ${escapedDescription.replace(
              /\n/g,
              "<br>"
            )}</p>
<label>État :
<select class="${prefix}_comp${idx}_classeCapacite">
<option value="capacité_spéciale">Neutre</option>
<option value="capacité_spéciale active">Active</option>
<option value="capacité_spéciale passive">Passive</option>
<option value="capacité_spéciale bloquée">Bloquée</option>
<option value="capacité_spéciale utilisée">Utilisée</option>
<option value="capacité_spéciale annulée">Annulée</option>
<option value="capacité_spéciale inactive">Inactive</option>
</select>
</label>
</div>
`;
          } else {
            // Si pas de ":", traiter comme une capacité sans titre
            const escapedLine = escapeHtml(cleanLine);
            container.innerHTML += `
<div class="capacite-container">
<input type="hidden" class="${prefix}_comp${idx}_titreCapacite" value="Capacité ${
              index + 1
            }">
<input type="hidden" class="${prefix}_comp${idx}_descriptionCapacite" value="${escapedLine}">
<p><strong><em>Capacité ${index + 1}</em></strong> : ${escapedLine.replace(
              /\n/g,
              "<br>"
            )}</p>
<label>État :
<select class="${prefix}_comp${idx}_classeCapacite">
<option value="capacité_spéciale">Neutre</option>
<option value="capacité_spéciale active">Active</option>
<option value="capacité_spéciale passive">Passive</option>
<option value="capacité_spéciale bloquée">Bloquée</option>
<option value="capacité_spéciale utilisée">Utilisée</option>
<option value="capacité_spéciale annulée">Annulée</option>
<option value="capacité_spéciale inactive">Inactive</option>
</select>
</label>
</div>
`;
          }
        });
      }

      function extractCharacter(prefix) {
        let html = `\n<strong class="${
          document.getElementById(`${prefix}_classe`).value
        }">${
          document.getElementById(`${prefix}_nom`).value
        }</strong> : <strong class="vitalité">${
          document.getElementById(`${prefix}_vitalite`).value
        }</strong>
<span class="bestiaire-champ">Vitesse</span> : <strong class="vitesse">${
          document.getElementById(`${prefix}_vitesse`).value
        }</strong>
`;

        if (document.getElementById(`${prefix}_corrompu`).checked) {
          html += `<span class="bestiaire-champ">Absorption</span> : <strong class="dégâts">${
            document.getElementById(`${prefix}_absorption`).value
          }%</strong>\n`;
        }

        html += `<span class="bestiaire-champ">Dégâts</span> : <strong class="dégâts">${
          document.getElementById(`${prefix}_degats`).value
        }</strong>
<span class="bestiaire-champ">Capacités spéciales</span> :`;

        const titres = Array.from(
          document.getElementsByClassName(`${prefix}_titreCapacite`)
        );
        const descs = Array.from(
          document.getElementsByClassName(`${prefix}_descriptionCapacite`)
        );
        const classes = Array.from(
          document.getElementsByClassName(`${prefix}_classeCapacite`)
        );

        if (titres.length > 0) {
          html += `\n<ul>`;
          for (let i = 0; i < titres.length; i++) {
            html += `<li class="${classes[i].value}"><em>${titres[i].value}</em> : ${descs[i].value}</li>\n`;
          }
          html += `</ul>`;
        } else {
          html += ` <em>Aucune capacité spéciale</em>`;
        }

        const noms = document.querySelectorAll(`.${prefix}_comp_nom`);
        const races = document.querySelectorAll(`.${prefix}_comp_race`);
        noms.forEach((compNom, idx) => {
          const race =
            document.querySelectorAll(`.${prefix}_comp_race`)[idx]?.value ||
            "Compagnon"; // Sélectionner la classe pour chaque compagnon
          const vit = document.querySelectorAll(`.${prefix}_comp_vitalite`)[idx]
            .value;
          const vitess = document.querySelectorAll(`.${prefix}_comp_vitesse`)[
            idx
          ].value;
          const deg = document.querySelectorAll(`.${prefix}_comp_degats`)[idx]
            .value;

          html += `\n
<strong class="${race}">${compNom.value}</strong> : <strong class="vitalité">${vit}</strong>
<span class="bestiaire-champ">Vitesse</span> : <strong class="vitesse">${vitess}</strong>
<span class="bestiaire-champ">Dégâts</span> : <strong class="dégâts">${deg}</strong>
<span class="bestiaire-champ">Capacités spéciales</span> : `;

          const comp_titles = document.querySelectorAll(
            `.${prefix}_comp${idx}_titreCapacite`
          );
          const comp_descs = document.querySelectorAll(
            `.${prefix}_comp${idx}_descriptionCapacite`
          );
          const comp_classes = document.querySelectorAll(
            `.${prefix}_comp${idx}_classeCapacite`
          );

          // Correction de "lenght" en "length"
          if (comp_titles.length > 0) {
            html += `\n<ul>`;
            for (let i = 0; i < comp_titles.length; i++) {
              html += `<li class="${comp_classes[i].value}"><em>${comp_titles[i].value}</em> : ${comp_descs[i].value}</li>\n`;
            }
            html += `</ul>`;
          } else {
            html += ` <em>Aucune capacité spéciale</em>`;
          }
        });
        return html;
      }

      function calculerVitesseTotale(prefix) {
        let totalVitesse = parseInt(
          document.getElementById(`${prefix}_vitesse`).value || 0
        );
        const compagnons = document.querySelectorAll(`.${prefix}_comp_vitesse`);
        compagnons.forEach((v) => (totalVitesse += parseInt(v.value || 0)));
        return totalVitesse;
      }

      function genererHTML() {
        const nb1 = parseInt(document.getElementById("nbGroupe1").value);
        const nb2 = parseInt(document.getElementById("nbGroupe2").value);

        let vitesseGroupe1 = 0;
        let vitesseGroupe2 = 0;

        let htmlG1 = ``;
        for (let i = 0; i < nb1; i++) {
          const prefix = `g1_p${i}`;
          htmlG1 += extractCharacter(prefix) + "\n";
          vitesseGroupe1 += calculerVitesseTotale(prefix);
        }

        let vitesseG1 =
          nb1 > 1
            ? `Vitesse de Groupe 1 : ${vitesseGroupe1}`
            : `Vitesse de ${
                document.getElementById("g1_p0_nom").value
              } : ${vitesseGroupe1}`;

        let htmlG2 = ``;
        for (let i = 0; i < nb2; i++) {
          const prefix = `g2_p${i}`;
          htmlG2 += extractCharacter(prefix) + "\n";
          vitesseGroupe2 += calculerVitesseTotale(prefix);
        }

        let vitesseG2 =
          nb2 > 1
            ? `Vitesse de Groupe 2 : ${vitesseGroupe2}`
            : `Vitesse de ${
                document.getElementById("g2_p0_nom").value
              } : ${vitesseGroupe2}`;

        const commence =
          vitesseGroupe1 >= vitesseGroupe2 ? "Groupe 1" : "Groupe 2";

        const headerTitle =
          nb1 > 1 && nb2 > 1
            ? "Groupe 1 contre Groupe 2"
            : `${
                nb1 === 1
                  ? document.getElementById("g1_p0_nom").value
                  : "Groupe 1"
              } contre ${
                nb2 === 1
                  ? document.getElementById("g2_p0_nom").value
                  : "Groupe 2"
              }`;

        const header = `<div class="titre">${headerTitle}</div>

<em>${commence} commence le combat</em>`;

        document.getElementById(
          "resultat"
        ).value = `${header}\n\n${vitesseG1}\n${htmlG1}\n\n<div class="combat-séparation">Contre</div>\n\n${vitesseG2}\n${htmlG2}`;
      }

      function toggleAbsorption(prefix) {
        const bloc = document.getElementById(`${prefix}_absorptionBloc`);
        const isChecked = document.getElementById(`${prefix}_corrompu`).checked;
        bloc.style.display = isChecked ? "block" : "none";
      }

      function collecterPersonnage(prefix) {
        const personnage = {
          nom: document.getElementById(`${prefix}_nom`).value,
          race: document.getElementById(`${prefix}_classe`).value,
          vitalite: document.getElementById(`${prefix}_vitalite`).value,
          vitesse: document.getElementById(`${prefix}_vitesse`).value,
          degats: document.getElementById(`${prefix}_degats`).value,
          corrompu: document.getElementById(`${prefix}_corrompu`).checked,
          absorption: document.getElementById(`${prefix}_absorption`).value,
          capacites: collecterCapacites(prefix),
          invocations: collecterInvocations(prefix),
        };
        return personnage;
      }

      function collecterCapacites(prefix) {
        const capacites = [];
        const titres = document.getElementsByClassName(
          `${prefix}_titreCapacite`
        );
        const descs = document.getElementsByClassName(
          `${prefix}_descriptionCapacite`
        );
        const classes = document.getElementsByClassName(
          `${prefix}_classeCapacite`
        );

        for (let i = 0; i < titres.length; i++) {
          capacites.push({
            titre: titres[i].value,
            description: descs[i].value,
            etat: classes[i].value,
          });
        }
        return capacites;
      }

      function collecterInvocations(prefix) {
        const invocations = [];
        const noms = document.querySelectorAll(`.${prefix}_comp_nom`);

        noms.forEach((_, idx) => {
          invocations.push({
            nom: document.querySelectorAll(`.${prefix}_comp_nom`)[idx].value,
            race: document.querySelectorAll(`.${prefix}_comp_race`)[idx].value,
            vitalite: document.querySelectorAll(`.${prefix}_comp_vitalite`)[idx]
              .value,
            vitesse: document.querySelectorAll(`.${prefix}_comp_vitesse`)[idx]
              .value,
            degats: document.querySelectorAll(`.${prefix}_comp_degats`)[idx]
              .value,
            capacites: collecterCapacitesInvocation(prefix, idx),
          });
        });
        return invocations;
      }

      function collecterCapacitesInvocation(prefix, idx) {
        const capacites = [];
        const titres = document.querySelectorAll(
          `.${prefix}_comp${idx}_titreCapacite`
        );
        const descs = document.querySelectorAll(
          `.${prefix}_comp${idx}_descriptionCapacite`
        );
        const classes = document.querySelectorAll(
          `.${prefix}_comp${idx}_classeCapacite`
        );

        for (let i = 0; i < titres.length; i++) {
          capacites.push({
            titre: titres[i].value,
            description: descs[i].value,
            etat: classes[i].value,
          });
        }
        return capacites;
      }

      function exporterPersonnage(prefix) {
        const personnage = collecterPersonnage(prefix);
        const nom = personnage.nom || "personnage";
        const blob = new Blob([JSON.stringify(personnage, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${nom}.json`;
        a.click();
      }

      function importerPersonnage(event, prefix) {
        const fichier = event.target.files[0];
        if (!fichier) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          const personnage = JSON.parse(e.target.result);
          remplirPersonnage(prefix, personnage);
        };
        reader.readAsText(fichier);
      }

      function remplirPersonnage(prefix, data) {
        // Remplir les champs de base
        document.getElementById(`${prefix}_nom`).value = data.nom;
        document.getElementById(`${prefix}_classe`).value = data.race;
        document.getElementById(`${prefix}_vitalite`).value = data.vitalite;
        document.getElementById(`${prefix}_vitesse`).value = data.vitesse;
        document.getElementById(`${prefix}_degats`).value = data.degats;
        document.getElementById(`${prefix}_corrompu`).checked = data.corrompu;

        // Gérer l'absorption si corrompu
        if (data.corrompu) {
          document.getElementById(`${prefix}_absorption`).value =
            data.absorption;
          toggleAbsorption(prefix); // Assurez-vous que le bloc d'absorption est visible
        }

        // Remplir les capacités
        const capacitesTexte = data.capacites
          .map((c) => `${c.titre} : ${c.description}`)
          .join("\n");
        document.getElementById(`${prefix}_capacites_input`).value =
          capacitesTexte;
        parseCapacites(prefix);

        // Mettre à jour les états des capacités
        const classes = document.getElementsByClassName(
          `${prefix}_classeCapacite`
        );
        data.capacites.forEach((c, i) => {
          if (classes[i]) classes[i].value = c.etat;
        });

        // Gérer les invocations
        if (data.invocations && data.invocations.length > 0) {
          document.getElementById(`${prefix}_nbCompagnons`).value =
            data.invocations.length;
          updateCompanions(prefix);
          data.invocations.forEach((inv, idx) => {
            remplirInvocation(prefix, idx, inv);
          });
        }
      }

      function remplirInvocation(prefix, idx, data) {
        const inputs = {
          nom: document.querySelectorAll(`.${prefix}_comp_nom`)[idx],
          race: document.querySelectorAll(`.${prefix}_comp_race`)[idx],
          vitalite: document.querySelectorAll(`.${prefix}_comp_vitalite`)[idx],
          vitesse: document.querySelectorAll(`.${prefix}_comp_vitesse`)[idx],
          degats: document.querySelectorAll(`.${prefix}_comp_degats`)[idx],
        };

        // Vérifier que tous les éléments existent avant de les remplir
        if (Object.values(inputs).every((el) => el)) {
          Object.entries(inputs).forEach(([key, el]) => (el.value = data[key]));

          // Remplir les capacités de l'invocation
          const capacitesTexte = data.capacites
            .map((c) => `${c.titre} : ${c.description}`)
            .join("\n");
          const inputCapacites = document.getElementById(
            `${prefix}_comp${idx}_capacites_input`
          );
          if (inputCapacites) {
            inputCapacites.value = capacitesTexte;
            parseCapacitesInvocations(prefix, idx);

            // Mettre à jour les états des capacités
            const classes = document.querySelectorAll(
              `.${prefix}_comp${idx}_classeCapacite`
            );
            data.capacites.forEach((c, i) => {
              if (classes[i]) classes[i].value = c.etat;
            });
          }
        }
      }

      function ajouterSpoiler(textareaId) {
        const textarea = document.getElementById(textareaId);
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const texteSelectionne = textarea.value.substring(start, end);

        if (start !== end) {
          const nouveauTexte =
            textarea.value.substring(0, start) +
            "[spoiler]" +
            texteSelectionne +
            "[/spoiler]" +
            textarea.value.substring(end);
          textarea.value = nouveauTexte;

          // Déclencher l'événement oninput pour mettre à jour le parsing
          if (textarea.oninput) textarea.oninput();

          // Replacer le curseur après le spoiler
          textarea.setSelectionRange(end + 19, end + 19); // 19 = longueur des balises ajoutées
        }
      }

      window.onload = function () {
        genererFormulairesGroupes();
      };
    </script>
  </body>
</html>
